/*
Config file handler generated by Nach's Config file handler creator.
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "md.h"

#define LINE_LENGTH 262144
static char line[LINE_LENGTH];

static char *encode_string(const char *str) {
	size_t i = 0;
	line[i++] = '\"';
	while (*str) {
		if ((*str == '\\') ||
			(*str == '\"') ||
			(*str == '\'') ||
			(*str == '\n') ||
			(*str == '\t')) {
			line[i++] = '\\';
		}
		line[i++] = *str++;
	}
	line[i++] = '\"';
	line[i] = 0;
	return (line);
}

static char *decode_string(char *str) {
	size_t str_len = strlen(str), i = 0;
	char *dest = str;

	if ((str_len > 1) && (*str == '\"') && (str[str_len - 1] == '\"')) {
		memmove(str, str + 1, str_len - 2);
		str[str_len - 2] = 0;

		while (*str) {
			if (*str == '\\') {
				str++;
			}
			dest[i++] = *str++;
		}
	}
	dest[i] = 0;
	return (dest);
}

static char *find_next_match(char *str, char match_char) {
	char *pos = 0;

	while (*str) {
		if (*str == match_char) {
			pos = str;
			break;
		}
		if (*str == '\\') {
			if (str[1]) {
				str++;
			} else {
				break;
			}
		}
		str++;
	}
	return (pos);
}

static char *find_str(char *str, char *match_str) {
	char *pos = 0;

	while (*str) {
		if (strchr(match_str, *str)) {
			pos = str;
			break;
		}
		if ((*str == '\"') || (*str == '\'')) {
			char *match_pos = 0;
			if ((match_pos = find_next_match(str + 1, *str))) {
				str = match_pos;
			}
		}
		str++;
	}
	return (pos);
}

static int atoui(const char *nptr) {
	return (strtoul(nptr, 0, 10));
}

// Copyright (C) 1997-2008 ZSNES Team ( zsKnight, _Demo_, pagefault, Nach )
//
// http://www.zsnes.com
// http://sourceforge.net/projects/zsnes
// https://zsnes.bountysource.com
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// version 2 as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

char md_raw_file[50];
char md_pcm_audio[50];
char md_compressed_audio[50];
char md_logo[50];
char md_ntsc[20];
char md_pal[5];
char md_file[50];
char md_prog[50];
char md_raw[150];
char md_other[75];
char md_no_sound[25];
char md_sound[100];
char md_compressed_sound[100];
char md_x264[100];
char md_ffv1[100];
char md_xvid[100];
char md_command[256];
char md_audio_compress[256];
char md_merge[256];

char md_custom_temp1[150];
char md_custom_temp2[150];
char md_custom_temp3[150];

unsigned char md_custom_passes = 3; // How many passes should be performed, make this at least 2
char md_custom_first_pass[512];
char md_custom_middle_passes[512];
char md_custom_last_pass[512];
char md_custom_pass_log_file[50];
char md_custom_pass_log_file2[50];

static unsigned char psr_init_done = 0;
static void init_md_vars() {
	if (!psr_init_done) {
		psr_init_done = 1;

		strcpy(md_raw_file, "rawvideo.bin");
		strcpy(md_pcm_audio, "audio.wav");
		strcpy(md_compressed_audio, "audio.mp3");
		strcpy(md_logo, "");
		strcpy(md_ntsc, "59649/995");
		strcpy(md_pal, "50/1");
		strcpy(md_file, "video.avi");
		strcpy(md_prog, "mencoder");
		strcpy(md_raw, "-demuxer rawvideo -rawvideo format=0x42475218:w=256:h=224:size=172032:fps=$md_video_rate");
		strcpy(md_other, "-aspect 4:3 -mc 0");
		strcpy(md_no_sound, "-nosound");
		strcpy(md_sound, "-oac mp3lame -lameopts aq=0:preset=64:mode=1 -audiofile $md_pcm_audio");
		strcpy(md_compressed_sound, "-oac copy -audiofile $md_compressed_audio");
		strcpy(md_x264, "-ovc x264 -x264encopts qp=0:frameref=15");
		strcpy(md_ffv1, "-ovc lavc -lavcopts vcodec=ffv1:vstrict=-2:aspect=4/3");
		strcpy(md_xvid, "-ovc xvid -xvidencopts fixed_quant=2");
		strcpy(md_command, "$md_prog $md_other $md_no_sound $md_raw $md_vcodec -o $md_file -");
		strcpy(md_audio_compress, "lame -m j --preset 64 -q 0 - $md_compressed_audio");
		strcpy(md_merge, "$md_prog $md_other $md_smode -force-avi-aspect 4:3 -ovc copy -o merged.avi $md_file");
		strcpy(md_custom_temp1, "-ovc x264 -x264encopts bframes=0:keyint=300:partitions=all:me=umh:frameref=15:subq=7:8x8dct:bitrate=350");
		strcpy(md_custom_temp2, "");
		strcpy(md_custom_temp3, "");
		strcpy(md_custom_first_pass, "$md_prog $md_other $md_no_sound $md_raw $md_custom_temp1:turbo=1:pass=1 -o $null -");
		strcpy(md_custom_middle_passes, "$md_prog $md_other $md_no_sound $md_raw $md_custom_temp1:pass=3 -o $null -");
		strcpy(md_custom_last_pass, "$md_prog $md_other $md_smode $md_raw $md_custom_temp1:pass=2 -o custom.avi -");
		strcpy(md_custom_pass_log_file, "divx2pass.log");
		strcpy(md_custom_pass_log_file2, "divx2pass.log.temp");
	}
}
static unsigned int PSR_HASH = 0x67915125;

static void write_md_vars_internal(void *fp, int (*outf)(void *, const char *, ...)) {
	outf(fp, "md_raw_file=%s ; Only for Raw Videos\n", encode_string(md_raw_file));
	outf(fp, "md_pcm_audio=%s ; AVI dumping always dumps audio seperatly\n", encode_string(md_pcm_audio));
	outf(fp, "md_compressed_audio=%s ; For when selecting compressed\n", encode_string(md_compressed_audio));
	outf(fp, "md_logo=%s ;If you want a logo, specify a logo file. It should be a series of frames 256x224x24.\n", encode_string(md_logo));
	outf(fp, "\n");
	outf(fp, "md_ntsc=%s\n", encode_string(md_ntsc));
	outf(fp, "md_pal=%s\n", encode_string(md_pal));
	outf(fp, "\n");
	outf(fp, "md_file=%s\n", encode_string(md_file));
	outf(fp, "md_prog=%s\n", encode_string(md_prog));
	outf(fp, "md_raw=%s\n", encode_string(md_raw));
	outf(fp, "md_other=%s\n", encode_string(md_other));
	outf(fp, "md_no_sound=%s\n", encode_string(md_no_sound));
	outf(fp, "md_sound=%s\n", encode_string(md_sound));
	outf(fp, "md_compressed_sound=%s\n", encode_string(md_compressed_sound));
	outf(fp, "md_x264=%s\n", encode_string(md_x264));
	outf(fp, "md_ffv1=%s\n", encode_string(md_ffv1));
	outf(fp, "md_xvid=%s\n", encode_string(md_xvid));
	outf(fp, "\n");
	outf(fp, ";%s\n", "Valid variables to use in the next four lines are:");
	outf(fp, ";%s\n", "$md_file, $md_prog, $md_raw, $md_other, $md_no_sound, $md_sound, $md_pcm_audio, $md_compressed_audio");
	outf(fp, ";%s\n", "and $md_video_rate, $md_vcodec, $md_smode");
	outf(fp, ";%s\n", "These variables are defined above.");
	outf(fp, ";%s\n", "$md_video_rate is $md_ntsc or $md_pal depending on the game as needed");
	outf(fp, ";%s\n", "$md_vcodec is $md_x264, $md_ffv1, or $md_xvid depending on the codec selected");
	outf(fp, ";%s\n", "$md_smode is $md_no_sound, $md_sound, or $md_compressed_sound depending on the audio options selected");
	outf(fp, "\n");
	outf(fp, "md_command=%s\n", encode_string(md_command));
	outf(fp, "md_audio_compress=%s\n", encode_string(md_audio_compress));
	outf(fp, "md_merge=%s\n", encode_string(md_merge));
	outf(fp, "\n");
	outf(fp, ";%s\n", "Code for how the custom option works.");
	outf(fp, "\n");
	outf(fp, ";%s\n", " These are 3 temporary variables you can use with the various passes");
	outf(fp, "md_custom_temp1=%s\n", encode_string(md_custom_temp1));
	outf(fp, "md_custom_temp2=%s\n", encode_string(md_custom_temp2));
	outf(fp, "md_custom_temp3=%s\n", encode_string(md_custom_temp3));
	outf(fp, "\n");
	outf(fp, ";%s\n", " Can use the same vars as above in addition to these temp ones.");
	outf(fp, ";%s\n", " Also $null for the nul file.");
	outf(fp, "\n");
	outf(fp, "md_custom_passes=%u\n", md_custom_passes);
	outf(fp, "md_custom_first_pass=%s\n", encode_string(md_custom_first_pass));
	outf(fp, "md_custom_middle_passes=%s\n", encode_string(md_custom_middle_passes));
	outf(fp, "md_custom_last_pass=%s\n", encode_string(md_custom_last_pass));
	outf(fp, "md_custom_pass_log_file=%s\n", encode_string(md_custom_pass_log_file));
	outf(fp, "md_custom_pass_log_file2=%s\n", encode_string(md_custom_pass_log_file2));
	outf(fp, "\n\n\n;Do not modify the following, for internal use only.\n");
	outf(fp, "PSR_HASH=%u\n", PSR_HASH);
}

unsigned char write_md_vars(const char *file) {
	FILE *fp = 0;

	init_md_vars();

	if ((fp = fopen(file, "w"))) {
		write_md_vars_internal(fp, (int (*)(void *, const char *, ...))fprintf);
		fclose(fp);

		return (1);
	}
	return (0);
}

static void read_md_vars_internal(void *fp, char *(*fin)(char *, int, void *), int (*fend)(void *)) {
	while (!fend(fp)) {
		char *p, *var, *value;

		fin(line, LINE_LENGTH, fp);
		if ((p = find_str(line, ";"))) { *p = 0; }
		if ((p = strchr(line, '='))) {
			*p = 0;
			var = line;
			value = p + 1;
			while (isspace(*var)) { var++; }
			while (isspace(*value)) { value++; }
			if ((p = find_str(var, " \t\r\n"))) { *p = 0; }
			if ((p = find_str(value, " \t\r\n"))) { *p = 0; }
			if (!*var || !*value) { continue; }
		} else {
			continue;
		}

		if (!strcmp(var, "md_raw_file")) {
			*md_raw_file = 0;
			strncat(md_raw_file, decode_string(value), sizeof(md_raw_file) - 1);
			continue;
		}
		if (!strcmp(var, "md_pcm_audio")) {
			*md_pcm_audio = 0;
			strncat(md_pcm_audio, decode_string(value), sizeof(md_pcm_audio) - 1);
			continue;
		}
		if (!strcmp(var, "md_compressed_audio")) {
			*md_compressed_audio = 0;
			strncat(md_compressed_audio, decode_string(value), sizeof(md_compressed_audio) - 1);
			continue;
		}
		if (!strcmp(var, "md_logo")) {
			*md_logo = 0;
			strncat(md_logo, decode_string(value), sizeof(md_logo) - 1);
			continue;
		}
		if (!strcmp(var, "md_ntsc")) {
			*md_ntsc = 0;
			strncat(md_ntsc, decode_string(value), sizeof(md_ntsc) - 1);
			continue;
		}
		if (!strcmp(var, "md_pal")) {
			*md_pal = 0;
			strncat(md_pal, decode_string(value), sizeof(md_pal) - 1);
			continue;
		}
		if (!strcmp(var, "md_file")) {
			*md_file = 0;
			strncat(md_file, decode_string(value), sizeof(md_file) - 1);
			continue;
		}
		if (!strcmp(var, "md_prog")) {
			*md_prog = 0;
			strncat(md_prog, decode_string(value), sizeof(md_prog) - 1);
			continue;
		}
		if (!strcmp(var, "md_raw")) {
			*md_raw = 0;
			strncat(md_raw, decode_string(value), sizeof(md_raw) - 1);
			continue;
		}
		if (!strcmp(var, "md_other")) {
			*md_other = 0;
			strncat(md_other, decode_string(value), sizeof(md_other) - 1);
			continue;
		}
		if (!strcmp(var, "md_no_sound")) {
			*md_no_sound = 0;
			strncat(md_no_sound, decode_string(value), sizeof(md_no_sound) - 1);
			continue;
		}
		if (!strcmp(var, "md_sound")) {
			*md_sound = 0;
			strncat(md_sound, decode_string(value), sizeof(md_sound) - 1);
			continue;
		}
		if (!strcmp(var, "md_compressed_sound")) {
			*md_compressed_sound = 0;
			strncat(md_compressed_sound, decode_string(value), sizeof(md_compressed_sound) - 1);
			continue;
		}
		if (!strcmp(var, "md_x264")) {
			*md_x264 = 0;
			strncat(md_x264, decode_string(value), sizeof(md_x264) - 1);
			continue;
		}
		if (!strcmp(var, "md_ffv1")) {
			*md_ffv1 = 0;
			strncat(md_ffv1, decode_string(value), sizeof(md_ffv1) - 1);
			continue;
		}
		if (!strcmp(var, "md_xvid")) {
			*md_xvid = 0;
			strncat(md_xvid, decode_string(value), sizeof(md_xvid) - 1);
			continue;
		}
		if (!strcmp(var, "md_command")) {
			*md_command = 0;
			strncat(md_command, decode_string(value), sizeof(md_command) - 1);
			continue;
		}
		if (!strcmp(var, "md_audio_compress")) {
			*md_audio_compress = 0;
			strncat(md_audio_compress, decode_string(value), sizeof(md_audio_compress) - 1);
			continue;
		}
		if (!strcmp(var, "md_merge")) {
			*md_merge = 0;
			strncat(md_merge, decode_string(value), sizeof(md_merge) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_temp1")) {
			*md_custom_temp1 = 0;
			strncat(md_custom_temp1, decode_string(value), sizeof(md_custom_temp1) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_temp2")) {
			*md_custom_temp2 = 0;
			strncat(md_custom_temp2, decode_string(value), sizeof(md_custom_temp2) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_temp3")) {
			*md_custom_temp3 = 0;
			strncat(md_custom_temp3, decode_string(value), sizeof(md_custom_temp3) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_passes")) {
			md_custom_passes = (unsigned char)atoui(value);
			continue;
		}
		if (!strcmp(var, "md_custom_first_pass")) {
			*md_custom_first_pass = 0;
			strncat(md_custom_first_pass, decode_string(value), sizeof(md_custom_first_pass) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_middle_passes")) {
			*md_custom_middle_passes = 0;
			strncat(md_custom_middle_passes, decode_string(value), sizeof(md_custom_middle_passes) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_last_pass")) {
			*md_custom_last_pass = 0;
			strncat(md_custom_last_pass, decode_string(value), sizeof(md_custom_last_pass) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_pass_log_file")) {
			*md_custom_pass_log_file = 0;
			strncat(md_custom_pass_log_file, decode_string(value), sizeof(md_custom_pass_log_file) - 1);
			continue;
		}
		if (!strcmp(var, "md_custom_pass_log_file2")) {
			*md_custom_pass_log_file2 = 0;
			strncat(md_custom_pass_log_file2, decode_string(value), sizeof(md_custom_pass_log_file2) - 1);
			continue;
		}
		if (!strcmp(var, "PSR_HASH")) {
			if ((unsigned int)atoui(value) == PSR_HASH) {
				psr_init_done = 2;
				continue;
			}
			break;
		}
	}
	if (psr_init_done == 2) {
		psr_init_done = 1;
	} else {
		psr_init_done = 0;
		init_md_vars();
	}
}

unsigned char read_md_vars(const char *file) {
	FILE *fp = 0;

	init_md_vars();

	if ((fp = fopen(file, "r"))) {
		read_md_vars_internal(fp, (char *(*)(char *, int, void *))fgets, (int (*)(void *))feof);
		fclose(fp);
		write_md_vars(file);
		return (1);
	}

	write_md_vars(file);
	return (0);
}
